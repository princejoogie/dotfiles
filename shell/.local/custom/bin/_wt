#!/usr/bin/sh

# Get the bare repo root (first worktree line)
get_bare_root() {
    git worktree list --porcelain | grep '^worktree' | head -1 | cut -d' ' -f2
}

case "$1" in
    list|ls)
        BARE_ROOT=$(get_bare_root)
        
        git worktree list --porcelain | awk -v bare_root="$BARE_ROOT" '
        /^worktree/ { 
            path = $2
            # Make path relative to bare root
            gsub("^" bare_root "/", "", path)
            gsub("^" bare_root "$", ".", path)
        }
        /^branch/ { 
            branch = $2
            gsub("refs/heads/", "", branch)
            print path " [" branch "]"
        }
        /^bare$/ {
            print path " (bare)"
        }'
        ;;
    cd)
        BARE_ROOT=$(get_bare_root)

        # Check if a specific worktree is provided as argument
        if [ -n "$2" ]; then
            SELECTED="$BARE_ROOT/$2"
        else
            # Get all worktree paths (excluding bare repo), select with fzf
            SELECTED=$(git worktree list --porcelain | grep '^worktree' | cut -d' ' -f2 | grep -v "^$BARE_ROOT$" | fzf)
        fi

        if [ -n "$SELECTED" ]; then
            cd "$SELECTED"
        fi
        ;;
    add)
        MAIN_REPO=$(get_bare_root)
        REPO_NAME=$(basename "$MAIN_REPO")

        # Check if a specific branch is provided as argument
        if [ -n "$2" ]; then
            SELECTED_BRANCH="$2"
        else
            # Get all branches and select one with fzf
            SELECTED_BRANCH=$(git branch -a | sed 's/^[* ] //' | sed 's|remotes/origin/||' | sort -u | grep -v '^HEAD' | fzf)
        fi

        if [ -n "$SELECTED_BRANCH" ]; then
            # Derive slug from branch name (last path component, lowercased)
            SLUG=$(echo "$SELECTED_BRANCH" | sed 's|.*/||' | tr '[:upper:]' '[:lower:]')
            WORKTREE="$HOME/.worktrees/$REPO_NAME/$SLUG"

            mkdir -p "$(dirname "$WORKTREE")"

            if git worktree add "$WORKTREE" "$SELECTED_BRANCH"; then
                # Look for .cursor/worktrees.json config
                CONFIG=""
                if [ -f "$WORKTREE/.cursor/worktrees.json" ]; then
                    CONFIG="$WORKTREE/.cursor/worktrees.json"
                elif [ -f "$MAIN_REPO/.cursor/worktrees.json" ]; then
                    CONFIG="$MAIN_REPO/.cursor/worktrees.json"
                fi

                if [ -n "$CONFIG" ] && command -v jq >/dev/null 2>&1; then
                    echo "Running setup from $CONFIG..."
                    export ROOT_WORKTREE_PATH="$MAIN_REPO"

                    # Prefer setup-worktree-unix, fallback to setup-worktree
                    SETUP_KEY="setup-worktree-unix"
                    if ! jq -e ".[\"$SETUP_KEY\"]" "$CONFIG" >/dev/null 2>&1; then
                        SETUP_KEY="setup-worktree"
                    fi

                    SETUP_TYPE=$(jq -r ".[\"$SETUP_KEY\"] | type" "$CONFIG" 2>/dev/null)

                    if [ "$SETUP_TYPE" = "array" ]; then
                        # Execute each command sequentially, stop on failure
                        jq -r ".[\"$SETUP_KEY\"][]" "$CONFIG" > "/tmp/wt_setup_$$"
                        while IFS= read -r cmd; do
                            echo "  Running: $cmd"
                            (cd "$WORKTREE" && eval "$cmd")
                            if [ $? -ne 0 ]; then
                                echo "  Setup failed on: $cmd"
                                break
                            fi
                        done < "/tmp/wt_setup_$$"
                        rm -f "/tmp/wt_setup_$$"
                    elif [ "$SETUP_TYPE" = "string" ]; then
                        # Single string = script path relative to worktree
                        SCRIPT=$(jq -r ".[\"$SETUP_KEY\"]" "$CONFIG")
                        echo "  Running script: $SCRIPT"
                        (cd "$WORKTREE" && sh "$SCRIPT")
                    fi
                else
                    # No config â€” copy env files and install deps manually

                    # Copy gitignored .env* files from main repo
                    echo "Copying environment files..."
                    (cd "$MAIN_REPO" && find . -name '.env*' -type f \
                        -not -name '*.sample' \
                        -not -path '*/node_modules/*' \
                        -not -path '*/.git/*' | while read -r f; do
                        if git check-ignore -q "$f" 2>/dev/null; then
                            mkdir -p "$WORKTREE/$(dirname "$f")"
                            cp "$f" "$WORKTREE/$f"
                            echo "  Copied $f"
                        fi
                    done)

                    # Install dependencies based on lockfile
                    echo "Installing dependencies..."
                    if [ -f "$WORKTREE/pnpm-lock.yaml" ]; then
                        (cd "$WORKTREE" && pnpm install)
                    elif [ -f "$WORKTREE/bun.lockb" ] || [ -f "$WORKTREE/bun.lock" ]; then
                        (cd "$WORKTREE" && bun install)
                    elif [ -f "$WORKTREE/yarn.lock" ]; then
                        (cd "$WORKTREE" && yarn install)
                    elif [ -f "$WORKTREE/package-lock.json" ]; then
                        (cd "$WORKTREE" && npm install)
                    elif [ -f "$WORKTREE/Cargo.toml" ]; then
                        (cd "$WORKTREE" && cargo build)
                    elif [ -f "$WORKTREE/requirements.txt" ]; then
                        (cd "$WORKTREE" && pip install -r requirements.txt)
                    elif [ -f "$WORKTREE/pyproject.toml" ]; then
                        (cd "$WORKTREE" && pip install -e .)
                    elif [ -f "$WORKTREE/go.mod" ]; then
                        (cd "$WORKTREE" && go mod download)
                    else
                        echo "  No recognized lockfile found, skipping"
                    fi
                fi

                cd "$WORKTREE"
                echo ""
                echo "Worktree ready at $WORKTREE"
                echo "Branch: $SELECTED_BRANCH"
            fi
        fi
        ;;
    remove|rm)
        BARE_ROOT=$(get_bare_root)

        # Check if a specific worktree is provided as argument
        if [ -n "$2" ]; then
            SELECTED="$BARE_ROOT/$2"
        else
            # Get all worktree paths (excluding bare repo), select with fzf
            SELECTED=$(git worktree list --porcelain | grep '^worktree' | cut -d' ' -f2 | grep -v "^$BARE_ROOT$" | fzf)
        fi

        if [ -n "$SELECTED" ]; then
            # Remove the selected worktree
            if git worktree remove --force "$SELECTED"; then
                echo "Worktree removed successfully"
            fi
        fi
        ;;
    *)
        echo "Usage: wt <command> [argument]"
        echo "Commands:"
        echo "  cd [name]         Select and switch to a worktree (or specify name directly)"
        echo "  add [branch]      Select a branch and create a new worktree (or specify branch directly)"
        echo "  remove|rm [name]  Select and remove a worktree (or specify name directly)"
        echo "  list|ls           List all worktrees"
        ;;
esac
